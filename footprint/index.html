---
layout: default
title: Footprint
---

<!-- ========== FOOTPRINT ========== -->
<div class="docs-section" id="footprint">
  <h3>Footprint</h3>
  <p>
    This is a collection of my travel experiences (after Sept. 2022 when I started my undergraduate). If you have great recommendations (or want some!) on the next destination, feel free to reach out!
    I’m always happy to chat about travel (especially the amazing local food)!
  </p>

  <p>
    <b><i>Remark:</i></b> The ratings are purely based on my personal experience and are quite <b>subjective</b>.
  </p>
  <!-- Map -->
  <div class="footprint-map-wrap">
    <div id="footprint-map" class="footprint-map" aria-label="Travel map"></div>
  </div>

  <!-- Gallery -->
  {% assign trips = site.data.footprint.trips %}
  {% for trip in trips %}
    <div class="footprint-trip" id="trip-{{ trip.id }}">
      <h4 class="footprint-trip-title">
        {{ trip.title }}
        <span class="footprint-trip-meta">· {{ trip.date }} · {% include stars.html rating=trip.rating %}</span>
      </h4>
      {% if trip.blurb %}
        <p class="footprint-trip-blurb">{{ trip.blurb }}</p>
      {% endif %}

      {% if trip.photos and trip.photos.size > 0 %}
        <div class="footprint-grid">
          {% for p in trip.photos %}
            <a class="footprint-thumb" href="{{ p | prepend: site.baseurl }}" data-trip="{{ trip.id }}" data-order="{{ forloop.index0 }}">
              <img
                class="lazy"
                loading="lazy"
                decoding="async"
                src="{{ '/assets/empty_300x200.png' | prepend: site.baseurl }}"
                data-src="{{ p | prepend: site.baseurl }}"
                alt="{{ trip.title }} photo">
            </a>
          {% endfor %}
        </div>
      {% else %}
        <p class="footprint-empty">Photos coming soon.</p>
      {% endif %}
    </div>
  {% endfor %}

  <!-- Lightbox (in-page viewer so clicking photos won't navigate to the raw .webp URL) -->
  <div class="footprint-lightbox" id="footprint-lightbox" aria-hidden="true">
    <div class="footprint-lightbox-backdrop" data-action="close"></div>
    <div class="footprint-lightbox-content" role="dialog" aria-modal="true" aria-label="Photo viewer">
      <button class="footprint-lightbox-close" type="button" data-action="close" aria-label="Close">×</button>
      <div class="footprint-lightbox-header">
        <div class="footprint-lightbox-title" id="footprint-lightbox-title"></div>
        <div class="footprint-lightbox-meta" id="footprint-lightbox-meta"></div>
      </div>
      <div class="footprint-lightbox-stage">
        <img class="footprint-lightbox-img" id="footprint-lightbox-img" alt="">
      </div>
      <button class="footprint-lightbox-nav footprint-lightbox-prev" type="button" data-action="prev" aria-label="Previous">‹</button>
      <button class="footprint-lightbox-nav footprint-lightbox-next" type="button" data-action="next" aria-label="Next">›</button>
    </div>
  </div>

  <!-- Trips data as JSON for safe parsing -->
  <script type="application/json" id="trips-json">
  [
    {% for trip in trips %}
    {
      "id": {{ trip.id | jsonify }},
      "title": {{ trip.title | jsonify }},
      "date": {{ trip.date | jsonify }},
      "rating": {{ trip.rating | jsonify }},
      "cover": {% if trip.cover %}{{ trip.cover | prepend: site.baseurl | jsonify }}{% elsif trip.photos and trip.photos.size > 0 %}{{ trip.photos.first | prepend: site.baseurl | jsonify }}{% else %}null{% endif %},
      "photos": [
        {% if trip.photos and trip.photos.size > 0 %}
          {% for p in trip.photos %}
            {{ p | prepend: site.baseurl | jsonify }}{% unless forloop.last %},{% endunless %}
          {% endfor %}
        {% endif %}
      ],
      "locations": [
        {% if trip.locations and trip.locations.size > 0 %}
          {% for loc in trip.locations %}
          {
            "city": {{ loc.city | jsonify }},
            "lat": {{ loc.coordinate[0] }},
            "lng": {{ loc.coordinate[1] }},
            "rating": {{ loc.rating | jsonify }},
            "cover": {% if loc.cover %}{{ loc.cover | prepend: site.baseurl | jsonify }}{% else %}null{% endif %}
          }{% unless forloop.last %},{% endunless %}
          {% endfor %}
        {% else %}
          {
            "city": null,
            "lat": {% if trip.lat != nil %}{{ trip.lat }}{% else %}null{% endif %},
            "lng": {% if trip.lng != nil %}{{ trip.lng }}{% else %}null{% endif %},
            "rating": {{ trip.rating | jsonify }},
            "cover": {% if trip.cover %}{{ trip.cover | prepend: site.baseurl | jsonify }}{% elsif trip.photos and trip.photos.size > 0 %}{{ trip.photos.first | prepend: site.baseurl | jsonify }}{% else %}null{% endif %}
          }
        {% endif %}
      ]
    }{% unless forloop.last %},{% endunless %}
    {% endfor %}
  ]
  </script>

  <!-- Placeholder URL for lazy-loaded images (keeps Liquid out of inline JS for linters) -->
  <span id="footprint-lazy-placeholder" data-src="{{ '/assets/empty_300x200.png' | prepend: site.baseurl }}" hidden></span>

  <!-- Leaflet (map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script>
    (function () {
      var mapEl = document.getElementById('footprint-map');
      if (!mapEl || !window.L) return;

      var phEl = document.getElementById('footprint-lazy-placeholder');
      var lazyPlaceholder = (phEl && phEl.getAttribute('data-src')) || '/assets/empty_300x200.png';

      var tripsEl = document.getElementById('trips-json');
      var trips = [];
      try {
        trips = JSON.parse(tripsEl ? tripsEl.textContent : '[]');
      } catch (e) {
        trips = [];
      }

      var map = L.map('footprint-map', { scrollWheelZoom: false, worldCopyJump: true });
      // Use an English-labeled basemap (no API key required)
      L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 18,
        attribution: 'Tiles &copy; Esri'
      }).addTo(map);

      var bounds = [];
      var isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
      // Prevent dragging into "grey" non-world area
      var worldBounds = L.latLngBounds(L.latLng(-85, -180), L.latLng(85, 180));
      map.setMaxBounds(worldBounds);
      map.options.maxBoundsViscosity = 1.0;
      var lastPopup = null;

      function popupHtml(t) {
        var stars = '';
        // simple mapping for our supported ratings
        var r = Number(t.rating);
        if (r === 0.5) stars = '★½☆☆☆';
        else if (r === 1) stars = '★☆☆☆☆';
        else if (r === 1.5) stars = '★½☆☆☆';
        else if (r === 2) stars = '★★☆☆☆';
        else if (r === 2.5) stars = '★★½☆☆';
        else if (r === 3) stars = '★★★☆☆';
        else if (r === 3.5) stars = '★★★½☆';
        else if (r === 4) stars = '★★★★☆';
        else if (r === 4.5) stars = '★★★★½';
        else if (r === 5) stars = '★★★★★';
        else stars = '☆☆☆☆☆';

        // Tooltip cover: load directly (only 1 image per click; avoids lazy/placeholder edge cases)
        var img = t.cover
          ? ('<img class="footprint-popup-img" src="' + t.cover + '" alt="cover" loading="lazy" decoding="async">')
          : '';
        var displayTitle = t.city ? (t.city + ', ' + t.tripTitle) : t.title;
        return '' +
          '<div class="footprint-popup">' +
          '  <div class="footprint-popup-title">' + displayTitle + '</div>' +
          '  <div class="footprint-popup-sub">' + t.date + ' · <span class="footprint-popup-stars">' + stars + '</span></div>' +
             img +
          '  <a class="footprint-popup-link" href="#trip-' + t.tripId + '">View gallery</a>' +
          '</div>';
      }

      // Flatten trip.locations into map markers (multiple cities per trip)
      var markers = [];
      trips.forEach(function (trip) {
        if (!trip || !trip.locations || !trip.locations.length) return;
        trip.locations.forEach(function (loc) {
          if (!loc || typeof loc.lat !== 'number' || typeof loc.lng !== 'number') return;
          markers.push({
            tripId: trip.id,
            tripTitle: trip.title,
            title: trip.title,
            date: trip.date,
            city: loc.city,
            lat: loc.lat,
            lng: loc.lng,
            rating: (loc.rating != null ? loc.rating : trip.rating),
            cover: (loc.cover || trip.cover || null)
          });
        });
      });

      markers.forEach(function (t) {
        bounds.push([t.lat, t.lng]);

        var m = L.circleMarker([t.lat, t.lng], {
          radius: 5,
          weight: 2,
          color: '#33006f',
          fillColor: '#ffffff',
          fillOpacity: 1,
          // Critical on touch devices: prevent marker clicks from bubbling to the map,
          // otherwise the map's click handler may immediately close the tooltip.
          bubblingMouseEvents: false
        }).addTo(map);

        // Use a popup (not tooltip) so it doesn't auto-close on marker mouseout (desktop UX).
        m.bindPopup(popupHtml(t), {
          // We'll handle "flip" ourselves (no auto-pan).
          autoPan: false,
          closeButton: false,
          closeOnClick: false,
          className: 'footprint-popup-leaflet',
          offset: [0, 0]
        });

          var closeTimer = null;
        var isOverPopup = false;
          function clearClose() {
            if (closeTimer) {
              clearTimeout(closeTimer);
              closeTimer = null;
            }
          }
        function scheduleClose() {
          clearClose();
          closeTimer = setTimeout(function () {
            if (!isOverPopup) m.closePopup();
          }, 220);
        }

        m.on('popupopen', function (e) {
          lastPopup = e && e.popup ? e.popup : lastPopup;
          clearClose();
          try {
            var el = e.popup && e.popup.getElement ? e.popup.getElement() : null;
            if (!el) return;

            // --- Popup auto placement (up/down/left/right) ---
            var dirClass = {
              up: 'footprint-popup-dir-up',
              down: 'footprint-popup-dir-down',
              left: 'footprint-popup-dir-left',
              right: 'footprint-popup-dir-right'
            };

            function setDirClass(dir) {
              try {
                el.classList.remove(dirClass.up, dirClass.down, dirClass.left, dirClass.right);
                el.classList.add(dirClass[dir] || dirClass.up);
              } catch (_e) {}
            }

            function computeOffsets(w, h, margin) {
              // Leaflet popup is positioned as: x = anchorX - w/2 + offsetX, y = anchorY - h + offsetY
              // We choose offset values to place popup around the anchor (marker).
              return {
                up:    { x: 0, y: -margin },
                down:  { x: 0, y: h + margin },
                left:  { x: -(w / 2 + margin), y: h / 2 },
                right: { x:  (w / 2 + margin), y: h / 2 }
              };
            }

            function rectForDir(anchor, w, h, margin, dir) {
              // anchor is in viewport coords (px)
              if (dir === 'up') {
                return { left: anchor.x - w / 2, right: anchor.x + w / 2, top: anchor.y - h - margin, bottom: anchor.y - margin };
              }
              if (dir === 'down') {
                return { left: anchor.x - w / 2, right: anchor.x + w / 2, top: anchor.y + margin, bottom: anchor.y + margin + h };
              }
              if (dir === 'left') {
                return { left: anchor.x - margin - w, right: anchor.x - margin, top: anchor.y - h / 2, bottom: anchor.y + h / 2 };
              }
              // right
              return { left: anchor.x + margin, right: anchor.x + margin + w, top: anchor.y - h / 2, bottom: anchor.y + h / 2 };
            }

            function overflowScore(r, bounds, pad) {
              var overL = Math.max(0, (bounds.left + pad) - r.left);
              var overR = Math.max(0, r.right - (bounds.right - pad));
              var overT = Math.max(0, (bounds.top + pad) - r.top);
              var overB = Math.max(0, r.bottom - (bounds.bottom - pad));
              return { score: overL + overR + overT + overB, overL: overL, overR: overR, overT: overT, overB: overB };
            }

            function chooseBestDir() {
              var mapContainer = map.getContainer ? map.getContainer() : null;
              if (!mapContainer || !el.getBoundingClientRect) return 'up';
              var mr = mapContainer.getBoundingClientRect();
              var pr = el.getBoundingClientRect();
              var w = pr.width || el.offsetWidth || 0;
              var h = pr.height || el.offsetHeight || 0;
              if (!w || !h) return 'up';

              // anchor in viewport coords
              var latlng = (e.popup && e.popup.getLatLng) ? e.popup.getLatLng() : null;
              if (!latlng || !map.latLngToContainerPoint) return 'up';
              var pt = map.latLngToContainerPoint(latlng);
              var anchor = { x: mr.left + pt.x, y: mr.top + pt.y };

              var pad = 8;
              var margin = 10;

              var dirs = ['up', 'down', 'right', 'left'];
              var best = { dir: 'up', score: Infinity };
              for (var i = 0; i < dirs.length; i++) {
                var d = dirs[i];
                var rr = rectForDir(anchor, w, h, margin, d);
                var sc = overflowScore(rr, mr, pad);
                if (sc.score < best.score) best = { dir: d, score: sc.score };
                if (sc.score === 0) return d; // perfect fit
              }
              return best.dir;
            }

            function applyDir(dir) {
              try {
                var pr = el.getBoundingClientRect();
                var w = pr.width || el.offsetWidth || 0;
                var h = pr.height || el.offsetHeight || 0;
                var margin = 10;
                var off = computeOffsets(w, h, margin)[dir] || { x: 0, y: -margin };
                setDirClass(dir);
                // Leaflet Popup doesn't reliably expose setOffset() across versions.
                // The supported approach is to mutate options.offset and call update().
                if (window.L && window.L.point) {
                  e.popup.options.offset = window.L.point(off.x, off.y);
                } else {
                  e.popup.options.offset = [off.x, off.y];
                }
                if (e.popup.update) e.popup.update();
                // Some versions require a position refresh after update.
                if (e.popup._updatePosition) e.popup._updatePosition();
              } catch (_e) {}
            }

            function adjustPlacement() {
              try {
                var dir = chooseBestDir();
                applyDir(dir);
              } catch (_e) {}
            }

            // Prevent clicks inside the popup from bubbling to the map.
            if (window.L && window.L.DomEvent) {
              window.L.DomEvent.disableClickPropagation(el);
              window.L.DomEvent.disableScrollPropagation(el);
            }

            var link = el.querySelector ? el.querySelector('a.footprint-popup-link') : null;
            if (link && window.L && window.L.DomEvent) {
              window.L.DomEvent.on(link, 'click', window.L.DomEvent.stopPropagation);
              window.L.DomEvent.on(link, 'mousedown', window.L.DomEvent.stopPropagation);
              window.L.DomEvent.on(link, 'touchstart', window.L.DomEvent.stopPropagation);
            }

            if (!isTouch) {
              el.addEventListener('mouseenter', function () {
                isOverPopup = true;
                clearClose();
              });
              el.addEventListener('mouseleave', function () {
                isOverPopup = false;
                m.closePopup();
              });
            }

            // Adjust placement after first paint and after the cover image loads (size changes).
            setTimeout(adjustPlacement, 0);
            try {
              var coverImg = el.querySelector ? el.querySelector('img.footprint-popup-img') : null;
              if (coverImg) coverImg.addEventListener('load', adjustPlacement, { once: true });
            } catch (_eimg) {}
            // Keep a reference so we can remove exactly this handler on close.
            e.popup.__footprintAdjustPlacement = adjustPlacement;
            map.on('moveend zoomend', adjustPlacement);
          } catch (_e) {}
        });
        m.on('popupclose', function (e) {
          if (lastPopup && e && e.popup && lastPopup === e.popup) lastPopup = null;
          try {
            var fn = e && e.popup ? e.popup.__footprintAdjustPlacement : null;
            if (fn) map.off('moveend zoomend', fn);
          } catch (_e) {}
        });

        m.on('click', function (evt) {
          // Prevent map click handler from firing on the same tap/click.
          try {
            if (evt && evt.originalEvent && window.L && window.L.DomEvent) {
              window.L.DomEvent.stopPropagation(evt.originalEvent);
            }
          } catch (_e) {}
          m.openPopup();
        });
        if (!isTouch) {
          m.on('mouseover', function () {
            clearClose();
            m.openPopup();
          });
          m.on('mouseout', function () {
            scheduleClose();
          });
        }
      });

      // On touch devices, tapping the map closes the open tooltip.
      if (isTouch) {
        map.on('click', function () {
          try {
            if (lastPopup) map.closePopup(lastPopup);
          } catch (_e) {}
          lastPopup = null;
        });
      } else {
        // Desktop: clicking the map closes the last tooltip (behaves like a popover)
        map.on('click', function () {
          try {
            if (lastPopup) map.closePopup(lastPopup);
          } catch (_e) {}
          lastPopup = null;
        });
      }

      if (bounds.length) {
        map.fitBounds(bounds, { padding: [40, 40] });
        // Allow a more zoomed-out default view
        if (map.getZoom() < 1) map.setZoom(1);
      } else {
        map.setView([20, 0], 1);
      }

      // --- Mobile gallery layout helpers (portrait 2-up, landscape full-width) ---
      function markOrientation(img) {
        if (!img || !img.closest) return;
        var a = img.closest('a.footprint-thumb');
        if (!a) return;
        if (!img.naturalWidth || !img.naturalHeight) return;
        var isLandscape = img.naturalWidth > img.naturalHeight;
        a.classList.toggle('landscape', isLandscape);
        a.classList.toggle('portrait', !isLandscape);
      }

      var imgs = document.querySelectorAll('#footprint .footprint-thumb img');
      imgs.forEach(function (img) {
        if (img.complete) {
          markOrientation(img);
        } else {
          img.addEventListener('load', function () { markOrientation(img); }, { once: true });
        }
      });

      // Reorder for mobile grid: keep portrait photos in pairs, avoid half-empty rows.
      var mmMobile = window.matchMedia && window.matchMedia('(max-width: 750px)');
      var relayoutTimer = null;
      function scheduleRelayout() {
        if (relayoutTimer) clearTimeout(relayoutTimer);
        relayoutTimer = setTimeout(relayoutMobileGrids, 50);
      }

      function ensureOrientationForThumb(a) {
        if (!a) return;
        var img = a.querySelector('img');
        if (!img || !img.naturalWidth || !img.naturalHeight) return;
        var isLandscape = img.naturalWidth > img.naturalHeight;
        a.classList.toggle('landscape', isLandscape);
        a.classList.toggle('portrait', !isLandscape);
      }

      function relayoutMobileGrids() {
        if (!mmMobile || !mmMobile.matches) return;
        var grids = document.querySelectorAll('#footprint .footprint-grid');
        grids.forEach(function (grid) {
          var items = Array.prototype.slice.call(grid.querySelectorAll('a.footprint-thumb'));
          items.forEach(ensureOrientationForThumb);

          // Keep original order index for restoration / stable reordering.
          items.sort(function (a, b) {
            var oa = parseInt(a.getAttribute('data-order') || '0', 10);
            var ob = parseInt(b.getAttribute('data-order') || '0', 10);
            return oa - ob;
          });

          // Build new sequence:
          // - portrait photos are paired in rows
          // - landscape photos always take a full row
          // - if a portrait would be left alone, make it full-width (class "full")
          var out = [];
          var pending = null;

          function pushPendingAsFull() {
            if (!pending) return;
            pending.classList.add('full');
            out.push(pending);
            pending = null;
          }

          for (var i = 0; i < items.length; i++) {
            var it = items[i];
            it.classList.remove('full');
            var isLand = it.classList.contains('landscape');

            if (isLand) {
              // If we have a single portrait pending, try to steal the next portrait to complete the row.
              if (pending) {
                var swapIdx = -1;
                for (var j = i + 1; j < items.length; j++) {
                  if (!items[j].classList.contains('landscape')) { swapIdx = j; break; }
                }
                if (swapIdx !== -1) {
                  var nextPortrait = items.splice(swapIdx, 1)[0];
                  nextPortrait.classList.remove('full');
                  out.push(pending);
                  out.push(nextPortrait);
                  pending = null;
                } else {
                  // No portrait left to pair with -> make this one full-width so no empty slot.
                  pushPendingAsFull();
                }
              }
              out.push(it);
            } else {
              // portrait
              if (!pending) pending = it;
              else {
                out.push(pending);
                out.push(it);
                pending = null;
              }
            }
          }
          if (pending) pushPendingAsFull();

          // Apply DOM order
          out.forEach(function (node) { grid.appendChild(node); });
        });
      }

      // Run once and also whenever images finish loading / viewport changes
      scheduleRelayout();
      imgs.forEach(function (img) {
        if (!img.complete) img.addEventListener('load', scheduleRelayout, { once: true });
      });
      if (mmMobile && mmMobile.addEventListener) mmMobile.addEventListener('change', scheduleRelayout);
      window.addEventListener('resize', scheduleRelayout);

      // ---- Lightbox ----
      var lb = document.getElementById('footprint-lightbox');
      var lbImg = document.getElementById('footprint-lightbox-img');
      var lbTitle = document.getElementById('footprint-lightbox-title');
      var lbMeta = document.getElementById('footprint-lightbox-meta');
      var lbStage = document.querySelector('#footprint-lightbox .footprint-lightbox-stage');
      var currentGlobalIndex = 0;
      var globalPhotos = [];
      var tripById = {};
      var tripStart = {};

      // When the full-res image finishes loading, re-fit to the current viewport.
      try {
        if (lbImg) lbImg.addEventListener('load', function () { fitToViewport(); });
      } catch (_e) {}

      function starsText(rating) {
        var r = Number(rating);
        if (r === 0.5) return '★½☆☆☆';
        if (r === 1) return '★☆☆☆☆';
        if (r === 1.5) return '★½☆☆☆';
        if (r === 2) return '★★☆☆☆';
        if (r === 2.5) return '★★½☆☆';
        if (r === 3) return '★★★☆☆';
        if (r === 3.5) return '★★★½☆';
        if (r === 4) return '★★★★☆';
        if (r === 4.5) return '★★★★½';
        if (r === 5) return '★★★★★';
        return '';
      }

      function getTripDisplay(tripId) {
        for (var i = 0; i < trips.length; i++) {
          if (trips[i] && trips[i].id === tripId) return trips[i];
        }
        return null;
      }

      // Build global photo list in trip order so next/prev continues across trips.
      (function buildGlobal() {
        var start = 0;
        for (var i = 0; i < trips.length; i++) {
          var t = trips[i];
          if (!t || !t.id) continue;
          tripById[t.id] = t;
          tripStart[t.id] = start;
          var photos = (t.photos && t.photos.length) ? t.photos : [];
          for (var j = 0; j < photos.length; j++) {
            globalPhotos.push({ tripId: t.id, href: photos[j], localIndex: j });
            start++;
          }
        }
      })();

      function renderLightbox(globalIdx) {
        if (!lb || !globalPhotos.length) return;
        currentGlobalIndex = (globalIdx + globalPhotos.length) % globalPhotos.length;
        var item = globalPhotos[currentGlobalIndex];
        var t = tripById[item.tripId] || getTripDisplay(item.tripId);
        lbTitle.textContent = (t && t.title) ? t.title : item.tripId;

        var meta = [];
        if (t && t.date) meta.push(t.date);
        if (t && t.rating != null) meta.push(starsText(t.rating));
        var totalInTrip = (t && t.photos && t.photos.length) ? t.photos.length : null;
        if (totalInTrip) meta.push((item.localIndex + 1) + '/' + totalInTrip);
        lbMeta.textContent = meta.filter(Boolean).join(' · ');

        lbImg.src = item.href;
        lbImg.alt = lbTitle.textContent + ' photo ' + (item.localIndex + 1);

        lb.classList.add('open');
        lb.setAttribute('aria-hidden', 'false');
        document.body.classList.add('footprint-no-scroll');

        // Ensure the image ALWAYS fits in the visible stage (desktop + mobile).
        requestAnimationFrame(fitToViewport);
      }

      function fitToViewport() {
        if (!lb || !lb.classList.contains('open')) return;
        if (!lbStage || !lbImg) return;
        // Stage is the only area the image can occupy.
        var rect = lbStage.getBoundingClientRect ? lbStage.getBoundingClientRect() : null;
        if (!rect) return;
        var w = Math.max(0, Math.floor(rect.width));
        var h = Math.max(0, Math.floor(rect.height));
        // Account for stage padding, otherwise the image can overflow and get clipped.
        try {
          var cs = window.getComputedStyle ? window.getComputedStyle(lbStage) : null;
          if (cs) {
            var pl = parseFloat(cs.paddingLeft || '0') || 0;
            var pr = parseFloat(cs.paddingRight || '0') || 0;
            var pt = parseFloat(cs.paddingTop || '0') || 0;
            var pb = parseFloat(cs.paddingBottom || '0') || 0;
            w = Math.max(0, w - pl - pr);
            h = Math.max(0, h - pt - pb);
          }
        } catch (_e) {}
        // Reserve a tiny margin so we never clip due to rounding.
        var pad = 2;
        lbImg.style.maxWidth = Math.max(0, w - pad) + 'px';
        lbImg.style.maxHeight = Math.max(0, h - pad) + 'px';
      }

      function openLightboxByTripOrder(tripId, orderIdx) {
        if (!globalPhotos.length) return;
        var base = tripStart[tripId];
        if (typeof base !== 'number') return;
        var idx = base + Math.max(0, (orderIdx || 0));
        renderLightbox(idx);
      }

      function closeLightbox() {
        if (!lb) return;
        lb.classList.remove('open');
        lb.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('footprint-no-scroll');
        if (lbImg) lbImg.src = '';
      }

      function nav(delta) {
        if (!globalPhotos.length) return;
        renderLightbox(currentGlobalIndex + delta);
      }

      // thumbnail click: prevent navigating to the raw image url; open lightbox instead
      document.addEventListener('click', function (e) {
        var a = e.target && e.target.closest ? e.target.closest('a.footprint-thumb') : null;
        if (!a) return;
        e.preventDefault();
        openLightboxByTripOrder(a.getAttribute('data-trip'), parseInt(a.getAttribute('data-order') || '0', 10));
      });

      // lightbox controls
      lb.addEventListener('click', function (e) {
        var t = e.target;
        var action = t && t.getAttribute ? t.getAttribute('data-action') : null;
        if (!action) return;
        e.preventDefault();
        if (action === 'close') closeLightbox();
        if (action === 'prev') nav(-1);
        if (action === 'next') nav(1);
      });
      document.addEventListener('keydown', function (e) {
        if (!lb || !lb.classList.contains('open')) return;
        if (e.key === 'Escape') closeLightbox();
        if (e.key === 'ArrowLeft') nav(-1);
        if (e.key === 'ArrowRight') nav(1);
      });

      // Swipe to navigate (mobile/tablet)
      (function initSwipe() {
        if (!lbStage) return;
        var startX = 0, startY = 0;
        var lastX = 0, lastY = 0;
        var tracking = false;
        var lockedAxis = null; // 'x' | 'y' | null

        function onStart(x, y) {
          tracking = true;
          lockedAxis = null;
          startX = lastX = x;
          startY = lastY = y;
        }
        function onMove(x, y) {
          if (!tracking) return;
          lastX = x; lastY = y;
          var dx = x - startX;
          var dy = y - startY;
          if (!lockedAxis) {
            if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
              lockedAxis = (Math.abs(dx) > Math.abs(dy) * 1.2) ? 'x' : 'y';
            }
          }
        }
        function onEnd() {
          if (!tracking) return;
          tracking = false;
          var dx = lastX - startX;
          var dy = lastY - startY;
          if (lockedAxis === 'x' && Math.abs(dx) > 60 && Math.abs(dx) > Math.abs(dy)) {
            if (dx < 0) nav(1);
            else nav(-1);
          }
        }

        // Touch (most reliable on mobile)
        lbStage.addEventListener('touchstart', function (e) {
          if (!lb.classList.contains('open')) return;
          var t = e && e.touches && e.touches[0];
          if (!t) return;
          onStart(t.clientX, t.clientY);
        }, { passive: true });
        lbStage.addEventListener('touchmove', function (e) {
          if (!lb.classList.contains('open')) return;
          var t = e && e.touches && e.touches[0];
          if (!t) return;
          onMove(t.clientX, t.clientY);
          // If it is a horizontal swipe, prevent page scrolling.
          if (lockedAxis === 'x') {
            try { e.preventDefault(); } catch (_e) {}
          }
        }, { passive: false });
        lbStage.addEventListener('touchend', function () { onEnd(); }, { passive: true });
        lbStage.addEventListener('touchcancel', function () { tracking = false; lockedAxis = null; }, { passive: true });

        // Pointer fallback (desktop trackpads / some Android)
        lbStage.addEventListener('pointerdown', function (e) {
          if (!lb.classList.contains('open')) return;
          onStart(e.clientX, e.clientY);
        });
        lbStage.addEventListener('pointermove', function (e) {
          if (!lb.classList.contains('open')) return;
          onMove(e.clientX, e.clientY);
        });
        lbStage.addEventListener('pointerup', function () { onEnd(); });
        lbStage.addEventListener('pointercancel', function () { tracking = false; lockedAxis = null; });
      })();

      // Re-fit on resize / orientation change while open
      window.addEventListener('resize', function () {
        if (!lb || !lb.classList.contains('open')) return;
        fitToViewport();
      });
      window.addEventListener('orientationchange', function () {
        if (!lb || !lb.classList.contains('open')) return;
        setTimeout(fitToViewport, 50);
      });
    })();
  </script>
</div>

