---
layout: default
title: Footprint
---

<!-- ========== FOOTPRINT ========== -->
<div class="docs-section" id="footprint">
  <h3>Footprint</h3>
  <p>
    This is a collection of my travel experiences (after Sept. 2022 when I started my undergraduate). If you have great recommendations (or want some!) on the next destination, feel free to reach out!
    I’m always happy to chat about travel (especially the amazing local food)!
  </p>

  <p>
    <b><i>Remark:</i></b> The ratings are purely based on my personal experience and are quite <b>subjective</b>.
  </p>
  <!-- Map -->
  <div class="footprint-map-wrap">
    <div id="footprint-map" class="footprint-map" aria-label="Travel map"></div>
  </div>

  <!-- Gallery -->
  {% assign trips = site.data.footprint.trips %}
  {% for trip in trips %}
    <div class="footprint-trip" id="trip-{{ trip.id }}">
      <h4 class="footprint-trip-title">
        {{ trip.title }}
        <span class="footprint-trip-meta">· {{ trip.date }} · {% include stars.html rating=trip.rating %}</span>
      </h4>
      {% if trip.blurb %}
        <p class="footprint-trip-blurb">{{ trip.blurb }}</p>
      {% endif %}

      {% if trip.photos and trip.photos.size > 0 %}
        <div class="footprint-grid">
          {% for p in trip.photos %}
            <a class="footprint-thumb" href="{{ p | prepend: site.baseurl }}" data-trip="{{ trip.id }}" data-order="{{ forloop.index0 }}">
              <img
                class="lazy"
                loading="lazy"
                decoding="async"
                src="{{ '/assets/empty_300x200.png' | prepend: site.baseurl }}"
                data-src="{{ p | prepend: site.baseurl }}"
                alt="{{ trip.title }} photo">
            </a>
          {% endfor %}
        </div>
      {% else %}
        <p class="footprint-empty">Photos coming soon.</p>
      {% endif %}
    </div>
  {% endfor %}

  <!-- Trips data as JSON for safe parsing -->
  <script type="application/json" id="trips-json">
  [
    {% for trip in trips %}
    {
      "id": {{ trip.id | jsonify }},
      "title": {{ trip.title | jsonify }},
      "date": {{ trip.date | jsonify }},
      "rating": {{ trip.rating | jsonify }},
      "cover": {% if trip.cover %}{{ trip.cover | prepend: site.baseurl | jsonify }}{% elsif trip.photos and trip.photos.size > 0 %}{{ trip.photos.first | prepend: site.baseurl | jsonify }}{% else %}null{% endif %},
      "locations": [
        {% if trip.locations and trip.locations.size > 0 %}
          {% for loc in trip.locations %}
          {
            "city": {{ loc.city | jsonify }},
            "lat": {{ loc.coordinate[0] }},
            "lng": {{ loc.coordinate[1] }},
            "rating": {{ loc.rating | jsonify }},
            "cover": {% if loc.cover %}{{ loc.cover | prepend: site.baseurl | jsonify }}{% else %}null{% endif %}
          }{% unless forloop.last %},{% endunless %}
          {% endfor %}
        {% else %}
          {
            "city": null,
            "lat": {% if trip.lat != nil %}{{ trip.lat }}{% else %}null{% endif %},
            "lng": {% if trip.lng != nil %}{{ trip.lng }}{% else %}null{% endif %},
            "rating": {{ trip.rating | jsonify }},
            "cover": {% if trip.cover %}{{ trip.cover | prepend: site.baseurl | jsonify }}{% elsif trip.photos and trip.photos.size > 0 %}{{ trip.photos.first | prepend: site.baseurl | jsonify }}{% else %}null{% endif %}
          }
        {% endif %}
      ]
    }{% unless forloop.last %},{% endunless %}
    {% endfor %}
  ]
  </script>

  <!-- Placeholder URL for lazy-loaded images (keeps Liquid out of inline JS for linters) -->
  <span id="footprint-lazy-placeholder" data-src="{{ '/assets/empty_300x200.png' | prepend: site.baseurl }}" hidden></span>

  <!-- Leaflet (map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script>
    (function () {
      var mapEl = document.getElementById('footprint-map');
      if (!mapEl || !window.L) return;

      var phEl = document.getElementById('footprint-lazy-placeholder');
      var lazyPlaceholder = (phEl && phEl.getAttribute('data-src')) || '/assets/empty_300x200.png';

      var tripsEl = document.getElementById('trips-json');
      var trips = [];
      try {
        trips = JSON.parse(tripsEl ? tripsEl.textContent : '[]');
      } catch (e) {
        trips = [];
      }

      var map = L.map('footprint-map', { scrollWheelZoom: false, worldCopyJump: true });
      // Use an English-labeled basemap (no API key required)
      L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 18,
        attribution: 'Tiles &copy; Esri'
      }).addTo(map);

      var bounds = [];
      var isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
      // Prevent dragging into "grey" non-world area
      var worldBounds = L.latLngBounds(L.latLng(-85, -180), L.latLng(85, 180));
      map.setMaxBounds(worldBounds);
      map.options.maxBoundsViscosity = 1.0;
      var lastPopup = null;

      function popupHtml(t) {
        var stars = '';
        // simple mapping for our supported ratings
        var r = Number(t.rating);
        if (r === 0.5) stars = '★½☆☆☆';
        else if (r === 1) stars = '★☆☆☆☆';
        else if (r === 1.5) stars = '★½☆☆☆';
        else if (r === 2) stars = '★★☆☆☆';
        else if (r === 2.5) stars = '★★½☆☆';
        else if (r === 3) stars = '★★★☆☆';
        else if (r === 3.5) stars = '★★★½☆';
        else if (r === 4) stars = '★★★★☆';
        else if (r === 4.5) stars = '★★★★½';
        else if (r === 5) stars = '★★★★★';
        else stars = '☆☆☆☆☆';

        // Tooltip cover: load directly (only 1 image per click; avoids lazy/placeholder edge cases)
        var img = t.cover
          ? ('<img class="footprint-popup-img" src="' + t.cover + '" alt="cover" loading="lazy" decoding="async">')
          : '';
        var displayTitle = t.city ? (t.city + ', ' + t.tripTitle) : t.title;
        return '' +
          '<div class="footprint-popup">' +
          '  <div class="footprint-popup-title">' + displayTitle + '</div>' +
          '  <div class="footprint-popup-sub">' + t.date + ' · <span class="footprint-popup-stars">' + stars + '</span></div>' +
             img +
          '  <a class="footprint-popup-link" href="#trip-' + t.tripId + '">View gallery</a>' +
          '</div>';
      }

      // Flatten trip.locations into map markers (multiple cities per trip)
      var markers = [];
      trips.forEach(function (trip) {
        if (!trip || !trip.locations || !trip.locations.length) return;
        trip.locations.forEach(function (loc) {
          if (!loc || typeof loc.lat !== 'number' || typeof loc.lng !== 'number') return;
          markers.push({
            tripId: trip.id,
            tripTitle: trip.title,
            title: trip.title,
            date: trip.date,
            city: loc.city,
            lat: loc.lat,
            lng: loc.lng,
            rating: (loc.rating != null ? loc.rating : trip.rating),
            cover: (loc.cover || trip.cover || null)
          });
        });
      });

      markers.forEach(function (t) {
        bounds.push([t.lat, t.lng]);

        var m = L.circleMarker([t.lat, t.lng], {
          radius: 5,
          weight: 2,
          color: '#33006f',
          fillColor: '#ffffff',
          fillOpacity: 1,
          // Critical on touch devices: prevent marker clicks from bubbling to the map,
          // otherwise the map's click handler may immediately close the tooltip.
          bubblingMouseEvents: false
        }).addTo(map);

        // Use a popup (not tooltip) so it doesn't auto-close on marker mouseout (desktop UX).
        m.bindPopup(popupHtml(t), {
          // We'll handle "flip" ourselves (no auto-pan).
          autoPan: false,
          closeButton: false,
          closeOnClick: false,
          className: 'footprint-popup-leaflet',
          offset: [0, 0]
        });

        var closeTimer = null;
        var isOverPopup = false;
        function clearClose() {
          if (closeTimer) {
            clearTimeout(closeTimer);
            closeTimer = null;
          }
        }
        function scheduleClose() {
          clearClose();
          closeTimer = setTimeout(function () {
            if (!isOverPopup) m.closePopup();
          }, 220);
        }

        m.on('popupopen', function (e) {
          lastPopup = e && e.popup ? e.popup : lastPopup;
          clearClose();
          try {
            var el = e.popup && e.popup.getElement ? e.popup.getElement() : null;
            if (!el) return;

            // --- Popup auto placement (up/down/left/right) ---
            var dirClass = {
              up: 'footprint-popup-dir-up',
              down: 'footprint-popup-dir-down',
              left: 'footprint-popup-dir-left',
              right: 'footprint-popup-dir-right'
            };

            function setDirClass(dir) {
              try {
                el.classList.remove(dirClass.up, dirClass.down, dirClass.left, dirClass.right);
                el.classList.add(dirClass[dir] || dirClass.up);
              } catch (_e) {}
            }

            function computeOffsets(w, h, margin) {
              // Leaflet popup is positioned as: x = anchorX - w/2 + offsetX, y = anchorY - h + offsetY
              // We choose offset values to place popup around the anchor (marker).
              return {
                up:    { x: 0, y: -margin },
                down:  { x: 0, y: h + margin },
                left:  { x: -(w / 2 + margin), y: h / 2 },
                right: { x:  (w / 2 + margin), y: h / 2 }
              };
            }

            function rectForDir(anchor, w, h, margin, dir) {
              // anchor is in viewport coords (px)
              if (dir === 'up') {
                return { left: anchor.x - w / 2, right: anchor.x + w / 2, top: anchor.y - h - margin, bottom: anchor.y - margin };
              }
              if (dir === 'down') {
                return { left: anchor.x - w / 2, right: anchor.x + w / 2, top: anchor.y + margin, bottom: anchor.y + margin + h };
              }
              if (dir === 'left') {
                return { left: anchor.x - margin - w, right: anchor.x - margin, top: anchor.y - h / 2, bottom: anchor.y + h / 2 };
              }
              // right
              return { left: anchor.x + margin, right: anchor.x + margin + w, top: anchor.y - h / 2, bottom: anchor.y + h / 2 };
            }

            function overflowScore(r, bounds, pad) {
              var overL = Math.max(0, (bounds.left + pad) - r.left);
              var overR = Math.max(0, r.right - (bounds.right - pad));
              var overT = Math.max(0, (bounds.top + pad) - r.top);
              var overB = Math.max(0, r.bottom - (bounds.bottom - pad));
              return { score: overL + overR + overT + overB, overL: overL, overR: overR, overT: overT, overB: overB };
            }

            function chooseBestDir() {
              var mapContainer = map.getContainer ? map.getContainer() : null;
              if (!mapContainer || !el.getBoundingClientRect) return 'up';
              var mr = mapContainer.getBoundingClientRect();
              var pr = el.getBoundingClientRect();
              var w = pr.width || el.offsetWidth || 0;
              var h = pr.height || el.offsetHeight || 0;
              if (!w || !h) return 'up';

              // anchor in viewport coords
              var latlng = (e.popup && e.popup.getLatLng) ? e.popup.getLatLng() : null;
              if (!latlng || !map.latLngToContainerPoint) return 'up';
              var pt = map.latLngToContainerPoint(latlng);
              var anchor = { x: mr.left + pt.x, y: mr.top + pt.y };

              var pad = 8;
              var margin = 10;

              var dirs = ['up', 'down', 'right', 'left'];
              var best = { dir: 'up', score: Infinity };
              for (var i = 0; i < dirs.length; i++) {
                var d = dirs[i];
                var rr = rectForDir(anchor, w, h, margin, d);
                var sc = overflowScore(rr, mr, pad);
                if (sc.score < best.score) best = { dir: d, score: sc.score };
                if (sc.score === 0) return d; // perfect fit
              }
              return best.dir;
            }

            function applyDir(dir) {
              try {
                var pr = el.getBoundingClientRect();
                var w = pr.width || el.offsetWidth || 0;
                var h = pr.height || el.offsetHeight || 0;
                var margin = 10;
                var off = computeOffsets(w, h, margin)[dir] || { x: 0, y: -margin };
                setDirClass(dir);
                // Leaflet Popup doesn't reliably expose setOffset() across versions.
                // The supported approach is to mutate options.offset and call update().
                if (window.L && window.L.point) {
                  e.popup.options.offset = window.L.point(off.x, off.y);
                } else {
                  e.popup.options.offset = [off.x, off.y];
                }
                if (e.popup.update) e.popup.update();
                // Some versions require a position refresh after update.
                if (e.popup._updatePosition) e.popup._updatePosition();
              } catch (_e) {}
            }

            function adjustPlacement() {
              try {
                var dir = chooseBestDir();
                applyDir(dir);
              } catch (_e) {}
            }

            // Prevent clicks inside the popup from bubbling to the map.
            if (window.L && window.L.DomEvent) {
              window.L.DomEvent.disableClickPropagation(el);
              window.L.DomEvent.disableScrollPropagation(el);
            }

            var link = el.querySelector ? el.querySelector('a.footprint-popup-link') : null;
            if (link && window.L && window.L.DomEvent) {
              window.L.DomEvent.on(link, 'click', window.L.DomEvent.stopPropagation);
              window.L.DomEvent.on(link, 'mousedown', window.L.DomEvent.stopPropagation);
              window.L.DomEvent.on(link, 'touchstart', window.L.DomEvent.stopPropagation);
            }

            if (!isTouch) {
              el.addEventListener('mouseenter', function () {
                isOverPopup = true;
                clearClose();
              });
              el.addEventListener('mouseleave', function () {
                isOverPopup = false;
                m.closePopup();
              });
            }

            // Adjust placement after first paint and after the cover image loads (size changes).
            setTimeout(adjustPlacement, 0);
            try {
              var coverImg = el.querySelector ? el.querySelector('img.footprint-popup-img') : null;
              if (coverImg) coverImg.addEventListener('load', adjustPlacement, { once: true });
            } catch (_eimg) {}
            // Keep a reference so we can remove exactly this handler on close.
            e.popup.__footprintAdjustPlacement = adjustPlacement;
            map.on('moveend zoomend', adjustPlacement);
          } catch (_e) {}
        });
        m.on('popupclose', function (e) {
          if (lastPopup && e && e.popup && lastPopup === e.popup) lastPopup = null;
          try {
            var fn = e && e.popup ? e.popup.__footprintAdjustPlacement : null;
            if (fn) map.off('moveend zoomend', fn);
          } catch (_e) {}
        });

        m.on('click', function (evt) {
          // Prevent map click handler from firing on the same tap/click.
          try {
            if (evt && evt.originalEvent && window.L && window.L.DomEvent) {
              window.L.DomEvent.stopPropagation(evt.originalEvent);
            }
          } catch (_e) {}
          m.openPopup();
        });
        if (!isTouch) {
          m.on('mouseover', function () {
            clearClose();
            m.openPopup();
          });
          m.on('mouseout', function () {
            scheduleClose();
          });
        }
      });

      // On touch devices, tapping the map closes the open tooltip.
      if (isTouch) {
        map.on('click', function () {
          try {
            if (lastPopup) map.closePopup(lastPopup);
          } catch (_e) {}
          lastPopup = null;
        });
      } else {
        // Desktop: clicking the map closes the last tooltip (behaves like a popover)
        map.on('click', function () {
          try {
            if (lastPopup) map.closePopup(lastPopup);
          } catch (_e) {}
          lastPopup = null;
        });
      }

      if (bounds.length) {
        map.fitBounds(bounds, { padding: [40, 40] });
        // Allow a more zoomed-out default view
        if (map.getZoom() < 1) map.setZoom(1);
      } else {
        map.setView([20, 0], 1);
      }

      // --- Mobile gallery layout helpers (portrait 2-up, landscape full-width) ---
      function markOrientation(img) {
        if (!img || !img.closest) return;
        var a = img.closest('a.footprint-thumb');
        if (!a) return;
        if (!img.naturalWidth || !img.naturalHeight) return;
        var isLandscape = img.naturalWidth > img.naturalHeight;
        a.classList.toggle('landscape', isLandscape);
        a.classList.toggle('portrait', !isLandscape);
      }

      var imgs = document.querySelectorAll('#footprint .footprint-thumb img');
      imgs.forEach(function (img) {
        if (img.complete) {
          markOrientation(img);
        } else {
          img.addEventListener('load', function () { markOrientation(img); }, { once: true });
        }
      });

      // Reorder for mobile grid: keep portrait photos in pairs, avoid half-empty rows.
      var mmMobile = window.matchMedia && window.matchMedia('(max-width: 750px)');
      var relayoutTimer = null;
      function scheduleRelayout() {
        if (relayoutTimer) clearTimeout(relayoutTimer);
        relayoutTimer = setTimeout(relayoutMobileGrids, 50);
      }

      function ensureOrientationForThumb(a) {
        if (!a) return;
        var img = a.querySelector('img');
        if (!img || !img.naturalWidth || !img.naturalHeight) return;
        var isLandscape = img.naturalWidth > img.naturalHeight;
        a.classList.toggle('landscape', isLandscape);
        a.classList.toggle('portrait', !isLandscape);
      }

      function relayoutMobileGrids() {
        if (!mmMobile || !mmMobile.matches) return;
        var grids = document.querySelectorAll('#footprint .footprint-grid');
        grids.forEach(function (grid) {
          var items = Array.prototype.slice.call(grid.querySelectorAll('a.footprint-thumb'));
          items.forEach(ensureOrientationForThumb);

          // Keep original order index for restoration / stable reordering.
          items.sort(function (a, b) {
            var oa = parseInt(a.getAttribute('data-order') || '0', 10);
            var ob = parseInt(b.getAttribute('data-order') || '0', 10);
            return oa - ob;
          });

          // Build new sequence:
          // - portrait photos are paired in rows
          // - landscape photos always take a full row
          // - if a portrait would be left alone, make it full-width (class "full")
          var out = [];
          var pending = null;

          function pushPendingAsFull() {
            if (!pending) return;
            pending.classList.add('full');
            out.push(pending);
            pending = null;
          }

          for (var i = 0; i < items.length; i++) {
            var it = items[i];
            it.classList.remove('full');
            var isLand = it.classList.contains('landscape');

            if (isLand) {
              // If we have a single portrait pending, try to steal the next portrait to complete the row.
              if (pending) {
                var swapIdx = -1;
                for (var j = i + 1; j < items.length; j++) {
                  if (!items[j].classList.contains('landscape')) { swapIdx = j; break; }
                }
                if (swapIdx !== -1) {
                  var nextPortrait = items.splice(swapIdx, 1)[0];
                  nextPortrait.classList.remove('full');
                  out.push(pending);
                  out.push(nextPortrait);
                  pending = null;
                } else {
                  // No portrait left to pair with -> make this one full-width so no empty slot.
                  pushPendingAsFull();
                }
              }
              out.push(it);
            } else {
              // portrait
              if (!pending) pending = it;
              else {
                out.push(pending);
                out.push(it);
                pending = null;
              }
            }
          }
          if (pending) pushPendingAsFull();

          // Apply DOM order
          out.forEach(function (node) { grid.appendChild(node); });
        });
      }

      // Run once and also whenever images finish loading / viewport changes
      scheduleRelayout();
      imgs.forEach(function (img) {
        if (!img.complete) img.addEventListener('load', scheduleRelayout, { once: true });
      });
      if (mmMobile && mmMobile.addEventListener) mmMobile.addEventListener('change', scheduleRelayout);
      window.addEventListener('resize', scheduleRelayout);
    })();
  </script>
</div>

